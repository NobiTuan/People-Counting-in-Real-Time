"""
People Counter with MobileNet SSD
Source: https://github.com/saimj7/People-Counting-in-Real-Time

Features:
- MobileNet SSD for human detection
- dlib correlation tracking
- Centroid tracking for ID assignment
- Frame rotation support (0, 90, 180, 270 degrees)
- Email alerts when threshold exceeded
- CSV logging
- Scheduling support
"""

from tracker.centroidtracker import CentroidTracker
from tracker.trackableobject import TrackableObject
from imutils.video import VideoStream
from itertools import zip_longest
from utils.mailer import Mailer
from imutils.video import FPS
from utils import thread
import numpy as np
import threading
import argparse
import datetime
import schedule
import logging
import imutils
import time
import dlib
import json
import csv
import cv2

# Execution start time
start_time = time.time()

# Setup logger
logging.basicConfig(level=logging.INFO, format="[INFO] %(message)s")
logger = logging.getLogger(__name__)

# Load configuration
with open("utils/config.json", "r") as file:
    config = json.load(file)


def parse_arguments():
    """Parse command line arguments"""
    ap = argparse.ArgumentParser(description="People Counter with MobileNet SSD")
    
    # MobileNet SSD model files
    ap.add_argument("-p", "--prototxt", required=True,
        help="path to Caffe 'deploy' prototxt file")
    ap.add_argument("-m", "--model", required=True,
        help="path to Caffe pre-trained model")
    
    # Input/Output
    ap.add_argument("-i", "--input", type=str,
        help="path to optional input video file")
    ap.add_argument("-o", "--output", type=str,
        help="path to optional output video file")
    
    # Detection parameters
    ap.add_argument("-c", "--confidence", type=float, default=0.4,
        help="minimum probability to filter weak detections (default: 0.4)")
    ap.add_argument("-s", "--skip-frames", type=int, default=30,
        help="number of skip frames between detections (default: 30)")
    
    # Line position
    ap.add_argument("-l", "--line-position", type=float, default=0.5,
        help="horizontal line position as fraction of height (0.0=top, 0.5=center, 1.0=bottom) (default: 0.5)")
    
    # Rotate frame
    ap.add_argument("-r", "--rotate", type=int, choices=[0, 90, 180, 270], default=0,
        help="rotate frame: 0 (no rotation), 90 (clockwise), 180, 270 (counter-clockwise) (default: 0)")
    
    args = vars(ap.parse_args())
    return args


def rotate_frame(frame, angle):
    """
    Rotate frame by specified angle
    
    Args:
        frame: Input frame (numpy array)
        angle: Rotation angle (0, 90, 180, 270)
    
    Returns:
        Rotated frame
    """
    if angle == 0:
        return frame
    elif angle == 90:
        return cv2.rotate(frame, cv2.ROTATE_90_CLOCKWISE)
    elif angle == 180:
        return cv2.rotate(frame, cv2.ROTATE_180)
    elif angle == 270:
        return cv2.rotate(frame, cv2.ROTATE_90_COUNTERCLOCKWISE)
    else:
        return frame


def send_mail():
    """Send email alerts when threshold exceeded"""
    try:
        Mailer().send(config["Email_Receive"])
    except Exception as e:
        logger.error(f"Failed to send email: {e}")


def log_data(move_in, in_time, move_out, out_time):
    """
    Log counting data to CSV file
    
    Args:
        move_in: List of people entering
        in_time: List of entry timestamps
        move_out: List of people exiting
        out_time: List of exit timestamps
    """
    data = [move_in, in_time, move_out, out_time]
    export_data = zip_longest(*data, fillvalue='')

    with open('utils/data/logs/counting_data.csv', 'w', newline='') as myfile:
        wr = csv.writer(myfile, quoting=csv.QUOTE_ALL)
        if myfile.tell() == 0:
            wr.writerow(("Move In", "In Time", "Move Out", "Out Time"))
            wr.writerows(export_data)


def people_counter():
    """Main people counting function with MobileNet SSD"""
    
    # Parse arguments
    args = parse_arguments()
    
    # Log rotation setting
    if args["rotate"] != 0:
        logger.info(f"Frame rotation enabled: {args['rotate']} degrees")
    
    # Initialize class labels MobileNet SSD was trained to detect
    CLASSES = ["background", "aeroplane", "bicycle", "bird", "boat",
        "bottle", "bus", "car", "cat", "chair", "cow", "diningtable",
        "dog", "horse", "motorbike", "person", "pottedplant", "sheep",
        "sofa", "train", "tvmonitor"]
    
    # Load MobileNet SSD model
    logger.info("Loading MobileNet SSD model...")
    net = cv2.dnn.readNetFromCaffe(args["prototxt"], args["model"])
    logger.info("MobileNet SSD model loaded successfully!")
    
    # Initialize video stream
    if not args.get("input", False):
        logger.info("Starting the live stream...")
        vs = VideoStream(config["url"]).start()
        time.sleep(2.0)
    else:
        logger.info("Starting the video...")
        vs = cv2.VideoCapture(args["input"])
    
    # Initialize video writer
    writer = None
    W = None
    H = None
    
    # Initialize centroid tracker
    ct = CentroidTracker(maxDisappeared=40, maxDistance=50)
    trackers = []
    trackableObjects = {}
    
    # Initialize counters
    totalFrames = 0
    totalDown = 0
    totalUp = 0
    total = []
    move_out = []
    move_in = []
    out_time = []
    in_time = []
    
    # Start FPS counter
    fps = FPS().start()
    
    # Use threading if enabled
    if config["Thread"]:
        vs = thread.ThreadingClass(config["url"])
    
    # Main processing loop
    while True:
        # Read frame
        frame = vs.read()
        frame = frame[1] if args.get("input", False) else frame
        
        # Check if video ended
        if args["input"] is not None and frame is None:
            break
        
        # Rotate frame if specified
        if args["rotate"] != 0:
            frame = rotate_frame(frame, args["rotate"])
        
        # Resize frame for faster processing
        frame = imutils.resize(frame, width=500)
        rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        
        # Get frame dimensions (after rotation)
        if W is None or H is None:
            (H, W) = frame.shape[:2]
        
        # Initialize video writer
        if args["output"] is not None and writer is None:
            fourcc = cv2.VideoWriter_fourcc(*"mp4v")
            writer = cv2.VideoWriter(args["output"], fourcc, 30, (W, H), True)
        
        # Initialize status and rects
        status = "Waiting"
        rects = []
        
        # Perform MobileNet SSD detection every N frames
        if totalFrames % args["skip_frames"] == 0:
            status = "Detecting"
            trackers = []
            
            # Create blob and pass through network
            blob = cv2.dnn.blobFromImage(frame, 0.007843, (W, H), 127.5)
            net.setInput(blob)
            detections = net.forward()
            
            # Loop over detections
            for i in np.arange(0, detections.shape[2]):
                confidence = detections[0, 0, i, 2]
                
                # Filter weak detections
                if confidence > args["confidence"]:
                    idx = int(detections[0, 0, i, 1])
                    
                    # Only detect person class
                    if CLASSES[idx] != "person":
                        continue
                    
                    # Compute bounding box
                    box = detections[0, 0, i, 3:7] * np.array([W, H, W, H])
                    (startX, startY, endX, endY) = box.astype("int")
                    
                    # Create dlib tracker
                    tracker = dlib.correlation_tracker()
                    rect = dlib.rectangle(startX, startY, endX, endY)
                    tracker.start_track(rgb, rect)
                    trackers.append(tracker)
        
        # Use existing trackers for other frames
        else:
            for tracker in trackers:
                status = "Tracking"
                
                # Update tracker
                tracker.update(rgb)
                pos = tracker.get_position()
                
                # Get bounding box
                startX = int(pos.left())
                startY = int(pos.top())
                endX = int(pos.right())
                endY = int(pos.bottom())
                
                rects.append((startX, startY, endX, endY))
        
        # Calculate line position
        line_y = int(H * args["line_position"])
        
        # Draw horizontal line (entrance border)
        cv2.line(frame, (0, line_y), (W, line_y), (0, 0, 0), 3)
        cv2.putText(frame, "-Prediction border - Entrance-", 
                   (10, line_y - 10),
                   cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 0), 1)
        
        # Update centroid tracker
        objects = ct.update(rects)
        
        # Loop over tracked objects
        for (objectID, centroid) in objects.items():
            # Get or create trackable object
            to = trackableObjects.get(objectID, None)
            
            if to is None:
                to = TrackableObject(objectID, centroid)
            else:
                # Calculate direction based on Y-axis
                y = [c[1] for c in to.centroids]
                direction = centroid[1] - np.mean(y)
                to.centroids.append(centroid)
                
                # Check if object needs to be counted
                if not to.counted:
                    # Moving UP (exiting)
                    if direction < 0 and centroid[1] < line_y:
                        totalUp += 1
                        date_time = datetime.datetime.now().strftime("%Y-%m-%d %H:%M")
                        move_out.append(totalUp)
                        out_time.append(date_time)
                        to.counted = True
                    
                    # Moving DOWN (entering)
                    elif direction > 0 and centroid[1] > line_y:
                        totalDown += 1
                        date_time = datetime.datetime.now().strftime("%Y-%m-%d %H:%M")
                        move_in.append(totalDown)
                        in_time.append(date_time)
                        
                        # Check threshold for alert
                        if sum(total) >= config["Threshold"]:
                            cv2.putText(frame, "-ALERT: People limit exceeded-", 
                                       (10, frame.shape[0] - 80),
                                       cv2.FONT_HERSHEY_COMPLEX, 0.5, (0, 0, 255), 2)
                            
                            if config["ALERT"]:
                                logger.info("Sending email alert...")
                                email_thread = threading.Thread(target=send_mail)
                                email_thread.daemon = True
                                email_thread.start()
                                logger.info("Alert sent!")
                        
                        to.counted = True
                        total = []
                        total.append(len(move_in) - len(move_out))
            
            # Store trackable object
            trackableObjects[objectID] = to
            
            # Draw object ID and centroid
            text = "ID {}".format(objectID)
            cv2.putText(frame, text, (centroid[0] - 10, centroid[1] - 10),
                       cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 255), 2)
            cv2.circle(frame, (centroid[0], centroid[1]), 4, (255, 255, 255), -1)
        
        # Prepare info for display
        info_status = [
            ("Exit", totalUp),
            ("Enter", totalDown),
            ("Status", status),
        ]
        
        info_total = [
            ("Total people inside", ', '.join(map(str, total))),
        ]
        
        # Display rotation info if enabled
        if args["rotate"] != 0:
            cv2.putText(frame, f"Rotation: {args['rotate']} deg", 
                       (W - 150, 20),
                       cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 255), 2)
        
        # Display status info
        for (i, (k, v)) in enumerate(info_status):
            text = "{}: {}".format(k, v)
            cv2.putText(frame, text, (10, H - ((i * 20) + 20)), 
                       cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 0, 0), 2)
        
        # Display total info
        for (i, (k, v)) in enumerate(info_total):
            text = "{}: {}".format(k, v)
            cv2.putText(frame, text, (265, H - ((i * 20) + 60)), 
                       cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 255, 255), 2)
        
        # Log data if enabled
        if config["Log"]:
            log_data(move_in, in_time, move_out, out_time)
        
        # Write frame to output video
        if writer is not None:
            writer.write(frame)
        
        # Display frame
        cv2.imshow("Real-Time Monitoring/Analysis Window", frame)
        key = cv2.waitKey(1) & 0xFF
        
        # Break on 'q' key
        if key == ord("q"):
            break
        
        # Update counters
        totalFrames += 1
        fps.update()
        
        # Timer to auto-stop (8 hours)
        if config["Timer"]:
            end_time = time.time()
            num_seconds = (end_time - start_time)
            if num_seconds > 28800:
                break
    
    # Stop FPS counter
    fps.stop()
    logger.info("Elapsed time: {:.2f}".format(fps.elapsed()))
    logger.info("Approx. FPS: {:.2f}".format(fps.fps()))
    
    # Release resources
    if config["Thread"]:
        vs.release()
    
    # Close windows
    cv2.destroyAllWindows()


# Main execution
if __name__ == "__main__":
    if config["Scheduler"]:
        schedule.every().day.at("09:00").do(people_counter)
        logger.info("Scheduler enabled. Waiting for scheduled time...")
        while True:
            schedule.run_pending()
            time.sleep(1)
    else:
        people_counter()